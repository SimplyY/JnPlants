<!-- ![image](https://cloud.githubusercontent.com/assets/8455579/8894523/fb892fea-33eb-11e5-88ba-5583e72495bd.png) -->
![image](http://img.hb.aicdn.com/0d141c6553edba7097dfd37c9e9ce8d13ee08b6fb5b6-thlQs9_fw658)

@(编程读书合集)

# csapp第一章导读

### 阅读心得
1. **理解底层** ，**构造层次型** 的计算机系统，从而设计更高效、健壮的计算机程序。
2. **桥梁**：系统性的学习计算机指令、虚拟存储器、编译原理、动态加载库、操作系统等，难得的跨领域贯穿计算机系统各个知识的书籍。
3. 接触计算机科学的各种领域，增加知识的广度和对计算机 **系统性** 的了解。

## 第一章：计算机系统漫游

#### 阅读心得
这一章会很有意思

#### 阅读心得
1. 计算机里的所有的程序、软件、视频、图片全是 `0 1` 和组成。之所以 `0 1` 能表示、储存东西，因为这些都是数据、是信息。而 **位 + 上下文**  使每一个 `0 1` 都有了它自己的意义，_就好比世间的绝大多数事物都是由原子和电子组成一样_。
2. 了解底层的编码的好处： 知道**本质的规律**，才可以 **避免一些错误的使用，** 而且所谓的编码 **只是对信息的一种模拟**，比如计算机对1/3这个值都无法精确模拟
3. 但是编码过于底层，`0 1` 对于人类，几乎是不可读的，更别谈去 _储存、处理、展示_ 数据了。所以就发明了 _汇编语言、高级编程语言_ 来对其底层封装。

### 1.2 程序被其他程序翻译成不同格式

#### 心得
程序的**编译系统**就是这四个阶段组成:

  1. 预处理器：将 _头文件内容_ 插入程序文本`hello.c`变成`hello.i`
  2. 编译器：将`hello.i`编译成汇编文件`hello.s`
  3. 汇编器：将`hello.s`翻译成 **机器语言指令** ，并打包到 **二进制文件** `hello.o`中，_切记是机器语言二进制指令不是字符_
  4. 链接器：将`hello.o`与引入的库中的函数（比如`printf`）的二进制文件`print.o`以某种方式合并在一起。此时就得到了`hello`文件，这是一个可执行的目标文件，可以被加载到内存中，被系统（硬件）调用。

### 1.3 了解编译系统如何工作的是大有益处的
1. 优化程序性能：无论是语言的语法还是我们写的函数，都是一种对 **底层的抽象** ，抽象不可避免的是 _信息的减少_ （有好处，使我们的精力更集中于**更关键的事** 上），这样以来，一件事有两种或更多种做法的时候，必然，有性能高低，并且我们能知道为什么，知道如何选择。
3. _就好比人类上万年前就发明了火，在对其原理的深刻认识后现在才能有打火机，无论是如何用更好，还是突破性的进展都和原理息息相关。_
4. 理解链接时出现的错误。还是由于抽象性的原因，我们写程序的时候只是在被语法限制，但实际上语法是一种抽象，不知道原理，，比如 `include` 或者 `import`，最容易在构建大型软件系统时出错，因为人总是会犯错，项目复杂性越高，错误越多，而不知原理，有的错误甚至无法解决，或者花大量时间。
6. 避免安全漏洞。原因与前者类似，比如 **缓冲区溢出** ，这与数据的存放在 **内存的堆栈原理** 有关。

### 1.4 处理器读并解释存储在存储器中的指令
此时我们的 hello.c 源程序已经被编译系统翻译成了可执行目标文件 hello，并存放在磁盘上。那么此时，可执行程序到底是如何运行的呢。

首先让我们了解一下系统的硬件组成的一些基本知识（先了解即可）


了解了基本的硬件知识后接下来，**最重要的来了可执行程序的运行**


#### 心得：
##### 了解 cpu 的结构，cpu 的对数据的操作有两种，高速储存、计算：
1. **总线接口** 用来和外界传输数据
2. 其中 **PC** 指向 **主存储器**， 处理器从指向位置读取数据。
3. **寄存器文件** 储存数据
4. **ALU（算术逻辑单元）** 用来计算新的数据和地址值
5. **寄存器 和 ALU** 组合使用就可以达到 **存放并执行** 的功能。

##### 程序的运行所经过的过程：
1. 外部输入命令（或者可以理解成双击 exe） ，主储存器开始加载可执行文件 `hello` 也就是将其文件中的机器代码（指令）和数据从磁盘复制到主存
2. 处理器通过总线接口，得到程序的指令和数据，并开始执行。
3. 由于 `printf` 转的指令会将执行的结果输出到`io` 设备（也就是显示屏）于是控制台看到了 `hello, world`

### 1.5 高速缓存至关重要
简单的示例指 hello 程序的运行


注意两幅图里面的黑线


#### 心得：
1. 较大储存设备要比较小的存储设备运行得慢，而快速设备造价极高
2. 对于不同设备，速度相差巨大，提升传输速度的秘诀在于建立高速缓存的中间层，这样以来高速设备是在跟高速缓冲打交道，速度更快。


#### 心得：
所有硬件都由操作系统来掌控，这样以来应用程序就不需要再和硬件打交道，是一种封装，并由此抽象出了不少概念 比如下文的进程、线程、虚拟存储器（内存）、文件系统



## 第三部分

#### 心得
- **上下文切换**（一个 CPU 看上去能并发的执行多个进程的原因）：
  - 是将当前进程的上下文（PC、寄存器、主存的所有信息）保存，也就是**暂停当前进程的运行**。
  - 并恢复新进程的上下文，以及将控制权传递给新进程，也就是**开始新进程的运行**。
  - 虽然 CPU 每一时刻最多只能运行一个进程，但是通过非常快的上下文切换，来达到多进程"同步"运行（每毫秒，多个进程都有序的运行了一段时间）。

- 这是一种很棒的封装以及很棒的思想：
  - 对于编码而言，就不需要去考虑硬件层面上 cpu 的控制了（cpu 通常用来进行计算），只需考虑进程的概念，大大降低了编程的复杂度。
  - 通过模拟并发（告诉替换上下文），使得电脑可以"同时"使用多个软件，而且这样对于耗时操作（网络请求、打电话等）就不会阻塞整个系统的运行。

### 线程
通常一个软件只有一个进程，多线程的概念使得软件能同时干多件事。

### 主存
> 这里的主存不是磁盘，是那个数值很小的一般电脑不超过20g，一般手机不超过 4g 的那个。 不是文件软件储存的地方，而是软件运行的地方。


#### 心得
- 操作系统会给每一个程序分配**封装好的存储空间**
  - 和进程同样的，这样以来，程序员不需要考虑对硬件层面上的主存进行操作。
  - 这段存储空间通常是程序运行时的变量数据（值类型的值、引用类型的堆空间）所存放的地方。

- **独立的存储空间**
  - 程序之间就不会互相影响，使得大量不同程序有序的**共用**唯一的主存。
  - 操作系统就能控制程序的主存的使用，以防止操作系统核心进程存储空间不够。

### 文件
> 我们的图片、视频、word、表格、软件这些都是文件，他们没有运行的时候一般都会静静的躺在磁盘里。


#### 心得
1. 封装了硬件，方便了编程。
2. **网络**。
  - 可以把我们手机的流量、wifi 看做俩网络io 设备，相当于两个可以进出的通道，数据流在那里流动。
  - 电脑也是一样。所以把网络看做 io 设备是一个很棒的事情，整个互联网对于你来说只是一个 io 设备，想想不是很酷么。

### 网络
> 下面演示了网络的运行原理，**信息是如何进入另外的主机**。


### 心得
很重的网络运行原理，我们浏览器都是通过这样的方式（上图）获取其他主机上的信息（html 、css、js 文件和数据） ，再运行成为我们看到的网页。

#### 抽象的重要性
> 整个计算机体系都是以抽象为灵魂来建立起骨架的。
